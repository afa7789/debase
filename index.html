<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>DEBASE</title>
    <link rel="icon" type="image/svg+xml" href="static/favicon.svg">
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
</head>

<body>

    <header>
        <a href="https://github.com/afa7789/debase">
            <h1>DEBASE</h1>
        </a>
    </header>

    <!-- Disclaimer and 1971 context -->
    <section style="margin-bottom: 2em;">
        <p style="font-weight:bold; color:#ffb300;">Disclaimer: This is a static demo web app for concept and testing purposes. Data and calculations may not be as accurate as they appear. Always verify with primary sources before making financial decisions.</p>
        <p><strong>Why 1971?</strong> — In 1971, the US ended the convertibility of the dollar to gold (the "Nixon Shock"), marking the start of the modern fiat era. Comparing assets from this point helps visualize long-term inflation and monetary effects on asset prices. <a href="https://wtfhappenedin1971.com/" target="_blank" rel="noopener" style="color:#ffb300; text-decoration:underline;">Learn more</a></p>
    </section>

    <!-- Gold Chart -->
    <section style="margin-bottom: 1em;">
        <p><strong>Gold Price Chart:</strong> Shows the price of gold in USD, both in nominal terms and adjusted for inflation. The "Fixed" line adjusts for inflation using the CPI from the start of the gold dataset, while the "1971" line adjusts from the year 1971. This helps visualize gold's real purchasing power over time.</p>
    </section>
    <div id="gold-chart" class="brutalist-chart"></div>
    <div class="ath-display">
        <p><strong>Gold ATH Normal:</strong> <span id="gold-ath-normal"></span></p>
        <p><strong>Gold ATH Adjusted (Fixed):</strong> <span id="gold-ath-inflation-fixed"></span></p>
        <p><strong>Gold ATH Adjusted (1971):</strong> <span id="gold-ath-inflation-1971"></span></p>
    </div>
    <br>

    <!-- ETH Chart -->
    <section style="margin-bottom: 1em;">
        <p><strong>Ethereum Price Chart:</strong> Plots ETH price in USD, both nominal and inflation-adjusted. The "Fixed" line uses inflation adjustment from ETH's launch date, while the "1971" line uses the multiplier from 1971. This shows how ETH's value compares to the changing value of money.</p>
    </section>
    <div id="eth-chart" class="brutalist-chart"></div>
    <div class="ath-display">
        <p><strong>ETH ATH Normal:</strong> <span id="eth-ath-normal"></span></p>
        <p><strong>ETH ATH Adjusted (Fixed):</strong> <span id="eth-ath-inflation-fixed"></span></p>
        <p><strong>ETH ATH Adjusted (1971):</strong> <span id="eth-ath-inflation-1971"></span></p>
    </div>
    <br>

    <!-- Bitcoin Chart -->
    <section style="margin-bottom: 1em;">
        <p><strong>Bitcoin Price Chart:</strong> Plots BTC price in USD, both nominal and inflation-adjusted. The "Fixed" line uses inflation adjustment from BTC's launch date, while the "1971" line uses the multiplier from 1971. This helps compare Bitcoin's real growth to the effects of inflation.</p>
    </section>
    <div id="btc-chart" class="brutalist-chart"></div>
    <div class="ath-display">
        <p><strong>BTC ATH Normal:</strong> <span id="btc-ath-normal"></span></p>
        <p><strong>BTC ATH Adjusted (Fixed):</strong> <span id="btc-ath-inflation-fixed"></span></p>
        <p><strong>BTC ATH Adjusted (1971):</strong> <span id="btc-ath-inflation-1971"></span></p>
    </div>
    <br>

    <!-- XMR Chart -->
    <section style="margin-bottom: 1em;">
        <p><strong>Monero Price Chart:</strong> Plots XMR price in USD, both nominal and inflation-adjusted. The "Fixed" line uses inflation adjustment from XMR's launch date, while the "1971" line uses the multiplier from 1971. This helps compare Monero's real growth to the effects of inflation.</p>
    </section>
    <div id="xmr-chart" class="brutalist-chart"></div>
    <div class="ath-display">
        <p><strong>XMR ATH Normal:</strong> <span id="xmr-ath-normal"></span></p>
        <p><strong>XMR ATH Adjusted (Fixed):</strong> <span id="xmr-ath-inflation-fixed"></span></p>
        <p><strong>XMR ATH Adjusted (1971):</strong> <span id="xmr-ath-inflation-1971"></span></p>
    </div>
    <br>

    <!-- Gold-Adjusted Crypto Chart -->
    <section style="margin-bottom: 1em;">
        <p><strong>Crypto Priced in Gold:</strong> These lines show the value of ETH, BTC, and XMR measured in ounces of gold, not dollars. This helps compare crypto performance to gold, a traditional store of value, and see which asset outperformed the other over time.</p>
    </section>
    <div id="gold-adjusted-crypto-chart" class="brutalist-chart"></div>
    <div class="ath-display">
        <p><strong>ETH/Gold ATH:</strong> <span id="eth-gold-ath"></span></p>
        <p><strong>BTC/Gold ATH:</strong> <span id="btc-gold-ath"></span></p>
        <p><strong>XMR/Gold ATH:</strong> <span id="xmr-gold-ath"></span></p>
    </div>
    <br>


    <!-- Relative Growth in USD  Chart -->
    <section style="margin-bottom: 1em;">
        <p><strong>Relative Growth (Comparison):</strong> This chart shows how much each crypto asset (BTC, ETH, XMR) has grown or shrunk relative to its own starting price in USD. Each line is normalized so its first price is 1.0, and every point after shows how many times the asset has multiplied (or divided) compared to its beginning.<br><br>
        <em>How to compare:</em> If one line is above another, it means that asset has grown more (in percentage terms) since its own launch, regardless of the initial price. For example, if BTC is at 10x and ETH is at 5x, BTC has multiplied 10 times and ETH 5 times since their respective first days. This lets you compare the relative performance and growth trajectory of each asset, even if they started at different times or prices.<br><br>
        <strong>Note:</strong> The Y-axis uses a logarithmic scale to make it easier to compare growth rates across assets that have multiplied by very different amounts.</p>
    </section>
    <div id="crypto-relative-growth-usd-chart" class="brutalist-chart"></div>
    <div class="ath-display">
        <p><strong>Each line starts at 1.0 (its own first USD price).</strong></p>
    </div>
    <br>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>

    <script>

        // Wait for idb to be available and define wrapper functions
        window.addEventListener('DOMContentLoaded', function () {
            console.log('idb library available:', typeof window.idb !== 'undefined');
            console.log('BigInt available:', typeof BigInt !== 'undefined');
        });

        // BigInt utility functions for financial calculations
        const SCALE = 1000000n; // 6 decimal places precision

        function toBigInt(value) {
            return BigInt(Math.round(value * Number(SCALE)));
        }

        function fromBigInt(bigintValue) {
            return Number(bigintValue) / Number(SCALE);
        }

        function bigIntDivide(numerator, denominator) {
            // Multiply by SCALE before division to maintain precision
            return (numerator * SCALE) / denominator;
        }

        function bigIntMultiply(a, b) {
            // Divide by SCALE after multiplication to maintain scale
            return (a * b) / SCALE;
        }

        // IndexedDB wrapper functions - must be defined before dataset_manager.js loads
        window.idbGet = async function (key) {
            try {
                // Check if idb is available
                if (typeof window.idb === 'undefined') {
                    throw new Error('idb library not loaded');
                }

                const db = await window.idb.openDB('csvDataStore', 1, {
                    upgrade(db) {
                        db.createObjectStore('datasets');
                    }
                });
                const result = await db.get('datasets', key);
                if (result !== undefined) return result;
            } catch (e) {
                console.warn('IndexedDB unavailable, falling back to localStorage:', e);
            }
            // Fallback to localStorage
            const stored = localStorage.getItem(key);
            return stored ? JSON.parse(stored) : null;
        };

        window.idbSet = async function (key, value) {
            try {
                // Check if idb is available
                if (typeof window.idb === 'undefined') {
                    throw new Error('idb library not loaded');
                }

                const db = await window.idb.openDB('csvDataStore', 1, {
                    upgrade(db) {
                        db.createObjectStore('datasets');
                    }
                });
                await db.put('datasets', value, key);
                return;
            } catch (e) {
                console.warn('IndexedDB unavailable, falling back to localStorage:', e);
            }
            // Fallback to localStorage
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (err) {
                console.error('Both IndexedDB and localStorage failed:', err);
            }
        };

        console.log('IndexedDB wrapper functions loaded');
    </script>

    <script src="scripts/dataset_manager.js"></script>

    <script src="scripts/import_from_kraken.js"></script>

    <script src="scripts/import_from_cpi.js"></script>

    <script>
        // The dates returned by csvManager.getFirstDate(GOLD) and csvManager.getFirstDate(CPI_U)
        // are strings in the format "YYYY-MM-DD,value1,value2,..."

        // Draw a brutalist D3 line chart - CSS-driven, mobile-first, NO DOTS
        // Modified to accept an array of data objects for multiple lines
        function drawCombinedChart(dataSets, divId = "combined-gold-chart", title = "PREÇO DO OURO", labelLeft = "USD $") {
            const chartDiv = document.getElementById(divId);

            if (!chartDiv) {
                console.log(`Chart container with id ${divId} not found.`);
                return;
            }

            const containerWidth = chartDiv.clientWidth;
            const containerHeight = chartDiv.clientHeight > 0 ? chartDiv.clientHeight : (window.innerWidth <= 600 ? 400 : 400);

            const internalWidth = containerWidth;
            const internalHeight = (window.innerWidth <= 400) ? 450 : (window.innerWidth <= 600 ? 400 : 400);

            const margin = {
                top: (window.innerWidth <= 400) ? 60 : (window.innerWidth <= 600 ? 50 : 40),
                right: (window.innerWidth <= 400) ? 20 : (window.innerWidth <= 600 ? 25 : 30),
                bottom: (window.innerWidth <= 400) ? 80 : (window.innerWidth <= 600 ? 70 : 60),
                left: (window.innerWidth <= 400) ? 55 : (window.innerWidth <= 600 ? 50 : 60)
            };

            // Clear previous chart
            d3.select(`#${divId}`).selectAll("*").remove();

            // Prepare data for all lines and determine combined domains
            let allDates = [];
            let allPrices = [];

            dataSets.forEach(dataSet => {
                dataSet.parsedData = dataSet.data.timestamp.map((d, i) => ({
                    date: new Date(d),
                    price: dataSet.data.price[i]
                }));
                allDates = allDates.concat(dataSet.parsedData.map(d => d.date));
                allPrices = allPrices.concat(dataSet.parsedData.map(d => d.price));
            });

            // Create SVG
            const svg = d3.select(`#${divId}`)
                .append("svg")
                .attr("width", internalWidth)
                .attr("height", internalHeight);

            // Scales
            const x = d3.scaleTime()
                .domain(d3.extent(allDates))
                .range([margin.left, internalWidth - margin.right]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(allPrices) * 1.05]).nice()
                .range([internalHeight - margin.bottom, margin.top]);

            // Grid lines
            const numXTicks = (window.innerWidth <= 400) ? 3 : (window.innerWidth <= 600 ? 4 : 6);
            const numYTicks = (window.innerWidth <= 400) ? 4 : (window.innerWidth <= 600 ? 5 : 6);

            // X-axis grid
            svg.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(0,${internalHeight - margin.bottom})`)
                .call(d3.axisBottom(x)
                    .ticks(numXTicks)
                    .tickSize(-(internalHeight - margin.top - margin.bottom))
                    .tickFormat("")
                );

            // Y-axis grid
            svg.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y)
                    .ticks(numYTicks)
                    .tickSize(-(internalWidth - margin.left - margin.right))
                    .tickFormat("")
                );

            // X-axis
            const xAxis = svg.append("g")
                .attr("transform", `translate(0,${internalHeight - margin.bottom})`)
                .call(d3.axisBottom(x).ticks(numXTicks));

            if (window.innerWidth <= 600) {
                xAxis.selectAll("text")
                    .attr("transform", "rotate(-45)")
                    .style("text-anchor", "end");
            }

            // Y-axis
            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).ticks(numYTicks));

            // Y-axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", (window.innerWidth <= 400) ? 10 : (window.innerWidth <= 600 ? 10 : 20))
                .attr("x", 0 - (internalHeight / 2))
                .attr("dy", "-1em")
                .style("text-anchor", "middle")
                .text(labelLeft);

            // Line generator
            const line = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.price))
                .curve(d3.curveLinear);

            // Draw each line
            dataSets.forEach(dataSet => {
                svg.append("path")
                    .datum(dataSet.parsedData)
                    .attr("class", `line ${dataSet.cssClass}`) // Add a specific class for styling
                    .attr("fill", "none")
                    .attr("stroke", dataSet.color) // Use the assigned color
                    .attr("d", line);
            });

            // Title
            svg.append("text")
                .attr("x", internalWidth / 2)
                .attr("y", (window.innerWidth <= 400) ? 30 : (window.innerWidth <= 600 ? 25 : 20))
                .attr("text-anchor", "middle")
                .text(title.toUpperCase());

            // Add Legend
            const legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${margin.left}, ${internalHeight - margin.bottom + 40})`); // Position legend below the chart

            dataSets.forEach((d, i) => {
                const legendRow = legend.append("g")
                    .attr("transform", `translate(0, ${i * 20})`); // Spacing between legend items

                legendRow.append("rect")
                    .attr("width", 10)
                    .attr("height", 10)
                    .attr("fill", d.color);

                legendRow.append("text")
                    .attr("x", 20)
                    .attr("y", 10)
                    .attr("text-anchor", "start")
                    .style("font-size", "0.8em")
                    .text(d.label);
            });
        }

        // Function to calculate the difference in days between two dates in "YYYY-MM-DD" format
        function daysBetween(dateStr1, dateStr2) {
            const d1 = new Date(dateStr1);
            const d2 = new Date(dateStr2);
            // Difference in milliseconds
            const diffMs = d1 - d2;
            // Convert to days
            return Math.round(diffMs / (1000 * 60 * 60 * 24));
        }

        // Function to process asset data with inflation adjustments using BigInt
        function processAssetWithInflation(assetName, sliceRangeCPI_U, multiplierForAsset1971) {
            const infoAsset = csvManager.getDatasetInfo(assetName);

            const inflationFixedAsset = {
                ATH: 0n,
                timestamp: [],
                price: [],
            };
            const inflationAsset1971 = {
                ATH: 0n,
                timestamp: [],
                price: [],
            };
            const normalAsset = {
                ATH: 0n,
                timestamp: [],
                price: [],
            };

            let multiplierFor1971 = toBigInt(multiplierForAsset1971);
            let multiplierForStart = SCALE; // Start with 1.0 in BigInt scale
            let counter = 0;

            csvManager.iterateRange(assetName,
                infoAsset.firstDate,
                infoAsset.lastDate,
                (date, data) => {
                    let currentDailyMultiplicator = SCALE; // Default to 1.0
                    if (counter < sliceRangeCPI_U.length && sliceRangeCPI_U[counter]) {
                        currentDailyMultiplicator = toBigInt(sliceRangeCPI_U[counter].daily_multiplicator);
                    } else if (sliceRangeCPI_U.length > 0) {
                        currentDailyMultiplicator = toBigInt(sliceRangeCPI_U[sliceRangeCPI_U.length - 1].daily_multiplicator);
                    }

                    multiplierFor1971 = bigIntMultiply(multiplierFor1971, currentDailyMultiplicator);
                    multiplierForStart = bigIntMultiply(multiplierForStart, currentDailyMultiplicator);

                    // Calculate inflation adjusted price for 1971 base
                    const closePrice = toBigInt(data.Close);
                    const highPrice = toBigInt(data.High);

                    const inflationAdjustedPrice1971 = bigIntDivide(closePrice, multiplierFor1971);
                    const highIAP1971 = bigIntDivide(highPrice, multiplierFor1971);
                    if (highIAP1971 > inflationAsset1971.ATH) {
                        inflationAsset1971.ATH = highIAP1971;
                    }
                    inflationAsset1971.timestamp.push(date);
                    inflationAsset1971.price.push(fromBigInt(inflationAdjustedPrice1971));

                    // Calculate inflation adjusted price for asset start base
                    const inflationAdjustedPriceFixed = bigIntDivide(closePrice, multiplierForStart);
                    const highIAPFixed = bigIntDivide(highPrice, multiplierForStart);
                    if (highIAPFixed > inflationFixedAsset.ATH) {
                        inflationFixedAsset.ATH = highIAPFixed;
                    }
                    inflationFixedAsset.timestamp.push(date);
                    inflationFixedAsset.price.push(fromBigInt(inflationAdjustedPriceFixed));

                    // Normal Asset Price
                    if (highPrice > normalAsset.ATH) {
                        normalAsset.ATH = highPrice;
                    }
                    normalAsset.timestamp.push(date);
                    normalAsset.price.push(fromBigInt(closePrice));

                    counter++;
                }
            );

            return {
                normal: {
                    ATH: fromBigInt(normalAsset.ATH),
                    timestamp: normalAsset.timestamp,
                    price: normalAsset.price
                },
                inflationFixed: {
                    ATH: fromBigInt(inflationFixedAsset.ATH),
                    timestamp: inflationFixedAsset.timestamp,
                    price: inflationFixedAsset.price
                },
                inflation1971: {
                    ATH: fromBigInt(inflationAsset1971.ATH),
                    timestamp: inflationAsset1971.timestamp,
                    price: inflationAsset1971.price
                }
            };
        }

        // Function to calculate gold-adjusted crypto prices using BigInt
        function calculateGoldAdjustedCrypto(cryptoData, goldData) {
            const goldAdjustedCrypto = {
                ATH: 0n,
                timestamp: [],
                price: []
            };

            // Find overlapping dates
            const cryptoDates = new Set(cryptoData.timestamp);
            const goldMap = new Map();

            goldData.timestamp.forEach((date, i) => {
                goldMap.set(date, toBigInt(goldData.price[i]));
            });

            cryptoData.timestamp.forEach((date, i) => {
                if (goldMap.has(date)) {
                    const cryptoPrice = toBigInt(cryptoData.price[i]);
                    const goldPrice = goldMap.get(date);
                    const adjustedPrice = bigIntDivide(cryptoPrice, goldPrice);

                    if (adjustedPrice > goldAdjustedCrypto.ATH) {
                        goldAdjustedCrypto.ATH = adjustedPrice;
                    }

                    goldAdjustedCrypto.timestamp.push(date);
                    goldAdjustedCrypto.price.push(fromBigInt(adjustedPrice));
                }
            });

            return {
                ATH: fromBigInt(goldAdjustedCrypto.ATH),
                timestamp: goldAdjustedCrypto.timestamp,
                price: goldAdjustedCrypto.price
            };
        }

        // Main application logic
        async function main() {
            console.log("Accessing global csvManager object:", csvManager);

            const GOLD = "GOLD";
            const CPI_U = "CPI_U";
            const XMR = "XMR";
            const ETH = "ETH";
            const BTC = "BTC";

            const datasetConfigs = [
            { name: CPI_U, csvPath: 'datasets/daily_cpi_inflation.csv', fetchFunction: fetchCpiUData },
            { name: GOLD, csvPath: 'datasets/gold.csv', fetchFunction: fetchGoldData },
            { name: XMR, csvPath: 'datasets/monero_2014-05-21_2025-07-10.csv', fetchFunction: fetchXmrData },
            { name: ETH, csvPath: 'datasets/ethereum_2015-08-07_2025-07-10.csv', fetchFunction: fetchEthData },
            { name: BTC, csvPath: 'datasets/bitcoin_2010-07-17_2025-07-10.csv', fetchFunction: fetchBtcData },
            ];

            // Initialize all datasets
            await csvManager.initAllDatasets(datasetConfigs);

            // Get CPI_U data once, as it's the base for all inflation calculations
            const fullCpiUData = csvManager.getDataRange(
            CPI_U,
            csvManager.getFirstDate(CPI_U),
            csvManager.getLastDate(CPI_U)
            );
            const cpiUFirstDate = csvManager.getFirstDate(CPI_U);

            // Helper function to get asset-specific inflation data
            function getAssetInflationParams(assetInfo) {
            const daysAfterCpiUStart = daysBetween(
                assetInfo.firstDate,
                cpiUFirstDate
            );

            let assetSliceRangeCPI_U = fullCpiUData.slice(daysAfterCpiUStart);

            // Ensure the first daily_multiplicator for the sliced range is 1
            if (assetSliceRangeCPI_U.length > 0) {
                assetSliceRangeCPI_U[0].daily_multiplicator = 1;
            }

            let assetMultiplierFor1971 = SCALE; // Start with 1.0
            // Calculate the multiplier from CPI_U start (1971) up to the asset's start date
            for (let i = 0; i < daysAfterCpiUStart; i++) {
                if (fullCpiUData[i]) {
                assetMultiplierFor1971 = bigIntMultiply(assetMultiplierFor1971, toBigInt(fullCpiUData[i].daily_multiplicator));
                } else {
                break;
                }
            }
            return { sliceRangeCPI_U: assetSliceRangeCPI_U, multiplierFor1971: fromBigInt(assetMultiplierFor1971) };
            }

            // --- Process Gold data ---
            const infoGOLD = csvManager.getDatasetInfo(GOLD);
            const goldInflationParams = getAssetInflationParams(infoGOLD);
            const goldData = processAssetWithInflation(GOLD, goldInflationParams.sliceRangeCPI_U, goldInflationParams.multiplierFor1971);

            // Display Gold ATH values
            document.getElementById('gold-ath-normal').textContent = `$${goldData.normal.ATH.toFixed(2)}`;
            document.getElementById('gold-ath-inflation-fixed').textContent = `$${goldData.inflationFixed.ATH.toFixed(2)}`;
            document.getElementById('gold-ath-inflation-1971').textContent = `$${goldData.inflation1971.ATH.toFixed(2)}`;

            // Draw Gold chart
            const goldChartData = [
            { data: goldData.normal, label: "Gold Price (Normal)", color: "orange", cssClass: "normal-gold-line" },
            { data: goldData.inflationFixed, label: "Gold Inflation Adjusted (Fixed)", color: "blue", cssClass: "inflation-fixed-line" },
            { data: goldData.inflation1971, label: "Gold Inflation Adjusted (1971)", color: "green", cssClass: "inflation-1971-line" }
            ];
            drawCombinedChart(goldChartData, "gold-chart", "Gold Price", "USD $");

            // --- Process ETH data ---
            const infoETH = csvManager.getDatasetInfo(ETH);
            const ethInflationParams = getAssetInflationParams(infoETH);
            const ethData = processAssetWithInflation(ETH, ethInflationParams.sliceRangeCPI_U, ethInflationParams.multiplierFor1971);
            document.getElementById('eth-ath-normal').textContent = `$${ethData.normal.ATH.toFixed(2)}`;
            document.getElementById('eth-ath-inflation-fixed').textContent = `$${ethData.inflationFixed.ATH.toFixed(2)}`;
            document.getElementById('eth-ath-inflation-1971').textContent = `$${ethData.inflation1971.ATH.toFixed(2)}`;

            const ethChartData = [
            { data: ethData.normal, label: "ETH Price (Normal)", color: "purple", cssClass: "normal-eth-line" },
            { data: ethData.inflationFixed, label: "ETH Inflation Adjusted (Fixed)", color: "blue", cssClass: "inflation-fixed-eth-line" },
            { data: ethData.inflation1971, label: "ETH Inflation Adjusted (1971)", color: "green", cssClass: "inflation-1971-eth-line" }
            ];
            drawCombinedChart(ethChartData, "eth-chart", "Ethereum Price", "USD $");

            // --- Process BTC data ---
            const infoBTC = csvManager.getDatasetInfo(BTC);
            const btcInflationParams = getAssetInflationParams(infoBTC);
            const btcData = processAssetWithInflation(BTC, btcInflationParams.sliceRangeCPI_U, btcInflationParams.multiplierFor1971);
            document.getElementById('btc-ath-normal').textContent = `$${btcData.normal.ATH.toFixed(2)}`;
            document.getElementById('btc-ath-inflation-fixed').textContent = `$${btcData.inflationFixed.ATH.toFixed(2)}`;
            document.getElementById('btc-ath-inflation-1971').textContent = `$${btcData.inflation1971.ATH.toFixed(2)}`;

            const btcChartData = [
            { data: btcData.normal, label: "BTC Price (Normal)", color: "orange", cssClass: "normal-btc-line" },
            { data: btcData.inflationFixed, label: "BTC Inflation Adjusted (Fixed)", color: "blue", cssClass: "inflation-fixed-btc-line" },
            { data: btcData.inflation1971, label: "BTC Inflation Adjusted (1971)", color: "green", cssClass: "inflation-1971-btc-line" }
            ];
            drawCombinedChart(btcChartData, "btc-chart", "Bitcoin Price", "USD $");

            // --- Process XMR data ---
            const infoXMR = csvManager.getDatasetInfo(XMR);
            const xmrInflationParams = getAssetInflationParams(infoXMR);
            const xmrData = processAssetWithInflation(XMR, xmrInflationParams.sliceRangeCPI_U, xmrInflationParams.multiplierFor1971);
            document.getElementById('xmr-ath-normal').textContent = `$${xmrData.normal.ATH.toFixed(2)}`;
            document.getElementById('xmr-ath-inflation-fixed').textContent = `$${xmrData.inflationFixed.ATH.toFixed(2)}`;
            document.getElementById('xmr-ath-inflation-1971').textContent = `$${xmrData.inflation1971.ATH.toFixed(2)}`;

            const xmrChartData = [
            { data: xmrData.normal, label: "XMR Price (Normal)", color: "red", cssClass: "normal-xmr-line" },
            { data: xmrData.inflationFixed, label: "XMR Inflation Adjusted (Fixed)", color: "blue", cssClass: "inflation-fixed-xmr-line" },
            { data: xmrData.inflation1971, label: "XMR Inflation Adjusted (1971)", color: "green", cssClass: "inflation-1971-xmr-line" }
            ];
            drawCombinedChart(xmrChartData, "xmr-chart", "Monero Price", "USD $");

            // Calculate gold-adjusted crypto prices using BigInt
            const ethGoldAdjusted = calculateGoldAdjustedCrypto(ethData.normal, goldData.normal);
            const btcGoldAdjusted = calculateGoldAdjustedCrypto(btcData.normal, goldData.normal);
            const xmrGoldAdjusted = calculateGoldAdjustedCrypto(xmrData.normal, goldData.normal);

            document.getElementById('eth-gold-ath').textContent = `${ethGoldAdjusted.ATH.toFixed(6)} oz`;
            document.getElementById('btc-gold-ath').textContent = `${btcGoldAdjusted.ATH.toFixed(6)} oz`;
            document.getElementById('xmr-gold-ath').textContent = `${xmrGoldAdjusted.ATH.toFixed(6)} oz`;

            const goldAdjustedChartData = [
                { data: ethGoldAdjusted, label: "ETH/Gold", color: "purple", cssClass: "eth-gold-line" },
                { data: btcGoldAdjusted, label: "BTC/Gold", color: "orange", cssClass: "btc-gold-line" },
                { data: xmrGoldAdjusted, label: "XMR/Gold", color: "red", cssClass: "xmr-gold-line" }
            ];
            drawCombinedChart(goldAdjustedChartData, "gold-adjusted-crypto-chart", "Crypto Assets Adjusted by Gold", "Ounces of Gold");



            // --- Improved Relative Growth in USD (No Gold) Chart ---
            function normalizeUsdSeriesFromOwnStart(series, assetName = "") {
                console.log(`Processing ${assetName}:`, {
                    dataLength: series.price.length,
                    firstPrice: series.price[0],
                    firstTimestamp: series.timestamp[0]
                });
                
                if (!series.price.length) {
                    console.warn(`No price data for ${assetName}`);
                    return { ...series };
                }
                
                // Find the first valid (non-zero, non-NaN) price
                let firstValidPrice = null;
                let firstValidIndex = -1;
                
                for (let i = 0; i < series.price.length; i++) {
                    const price = series.price[i];
                    if (price && !isNaN(price) && price > 0) {
                        firstValidPrice = price;
                        firstValidIndex = i;
                        break;
                    }
                }
                
                if (firstValidPrice === null) {
                    console.warn(`No valid first price for ${assetName}, all values are zero or invalid`);
                    return {
                        ...series,
                        price: series.price.map(_ => NaN),
                    };
                }
                
                console.log(`${assetName} first valid price: ${firstValidPrice} at index ${firstValidIndex}`);
                
                // Start from the first valid price point
                const normalizedTimestamps = series.timestamp.slice(firstValidIndex);
                const normalizedPrices = series.price.slice(firstValidIndex).map(price => {
                    if (!price || isNaN(price) || price <= 0) {
                        return NaN; // Handle invalid data points
                    }
                    return price / firstValidPrice;
                });
                
                console.log(`${assetName} normalized:`, {
                    length: normalizedPrices.length,
                    firstNormalized: normalizedPrices[0],
                    lastNormalized: normalizedPrices[normalizedPrices.length - 1],
                    maxValue: Math.max(...normalizedPrices.filter(p => !isNaN(p)))
                });
                
                return {
                    timestamp: normalizedTimestamps,
                    price: normalizedPrices,
                };
            }

            // Apply normalization with better error handling
            const btcUsdRelative = normalizeUsdSeriesFromOwnStart(btcData.normal, "BTC");
            const ethUsdRelative = normalizeUsdSeriesFromOwnStart(ethData.normal, "ETH");
            const xmrUsdRelative = normalizeUsdSeriesFromOwnStart(xmrData.normal, "XMR");

            // Enhanced chart data with better colors and styling
            const cryptoRelativeGrowthUsdChartData = [
                { 
                    data: btcUsdRelative, 
                    label: "BTC (USD Relative Growth)", 
                    color: "#f7931a", // Bitcoin orange
                    cssClass: "btc-usd-rel-line" 
                },
                { 
                    data: ethUsdRelative, 
                    label: "ETH (USD Relative Growth)", 
                    color: "#627eea", // Ethereum blue
                    cssClass: "eth-usd-rel-line" 
                },
                { 
                    data: xmrUsdRelative, 
                    label: "XMR (USD Relative Growth)", 
                    color: "#ff6600", // Monero orange
                    cssClass: "xmr-usd-rel-line" 
                }
            ];

            // Modified drawCombinedChart function for better logarithmic scaling
            function drawRelativeGrowthChart(dataSets, divId = "crypto-relative-growth-usd-chart") {
                const chartDiv = document.getElementById(divId);
                if (!chartDiv) {
                    console.log(`Chart container with id ${divId} not found.`);
                    return;
                }

                const containerWidth = chartDiv.clientWidth;
                const containerHeight = chartDiv.clientHeight > 0 ? chartDiv.clientHeight : (window.innerWidth <= 600 ? 400 : 400);

                const internalWidth = containerWidth;
                const internalHeight = (window.innerWidth <= 400) ? 450 : (window.innerWidth <= 600 ? 400 : 400);

                const margin = {
                    top: (window.innerWidth <= 400) ? 60 : (window.innerWidth <= 600 ? 50 : 40),
                    right: (window.innerWidth <= 400) ? 20 : (window.innerWidth <= 600 ? 25 : 30),
                    bottom: (window.innerWidth <= 400) ? 80 : (window.innerWidth <= 600 ? 70 : 60),
                    left: (window.innerWidth <= 400) ? 70 : (window.innerWidth <= 600 ? 65 : 80) // More space for larger numbers
                };

                // Clear previous chart
                d3.select(`#${divId}`).selectAll("*").remove();

                // Prepare data and find valid ranges
                let allDates = [];
                let allPrices = [];
                let validDataSets = [];

                dataSets.forEach(dataSet => {
                    const validPrices = dataSet.data.price.filter(p => !isNaN(p) && p > 0);
                    if (validPrices.length > 0) {
                        dataSet.parsedData = dataSet.data.timestamp.map((d, i) => ({
                            date: new Date(d),
                            price: dataSet.data.price[i]
                        })).filter(d => !isNaN(d.price) && d.price > 0);
                        
                        if (dataSet.parsedData.length > 0) {
                            validDataSets.push(dataSet);
                            allDates = allDates.concat(dataSet.parsedData.map(d => d.date));
                            allPrices = allPrices.concat(dataSet.parsedData.map(d => d.price));
                        }
                    }
                });

                if (validDataSets.length === 0) {
                    console.error("No valid data to display in relative growth chart");
                    return;
                }

                // Create SVG
                const svg = d3.select(`#${divId}`)
                    .append("svg")
                    .attr("width", internalWidth)
                    .attr("height", internalHeight);

                // Scales - Use log scale for Y-axis to better show relative growth
                const x = d3.scaleTime()
                    .domain(d3.extent(allDates))
                    .range([margin.left, internalWidth - margin.right]);

                const maxPrice = d3.max(allPrices);
                const minPrice = d3.min(allPrices.filter(p => p > 0));
                
                // Use log scale if the range is very large, otherwise linear
                const useLogScale = maxPrice / minPrice > 100;
                
                let y;
                if (useLogScale) {
                    y = d3.scaleLog()
                        .domain([Math.max(minPrice * 0.8, 0.1), maxPrice * 1.2])
                        .range([internalHeight - margin.bottom, margin.top])
                        .clamp(true);
                } else {
                    y = d3.scaleLinear()
                        .domain([0, maxPrice * 1.05])
                        .range([internalHeight - margin.bottom, margin.top]);
                }

                // Grid lines
                const numXTicks = (window.innerWidth <= 400) ? 3 : (window.innerWidth <= 600 ? 4 : 6);
                const numYTicks = (window.innerWidth <= 400) ? 4 : (window.innerWidth <= 600 ? 5 : 6);

                // X-axis grid
                svg.append("g")
                    .attr("class", "grid")
                    .attr("transform", `translate(0,${internalHeight - margin.bottom})`)
                    .call(d3.axisBottom(x)
                        .ticks(numXTicks)
                        .tickSize(-(internalHeight - margin.top - margin.bottom))
                        .tickFormat("")
                    );

                // Y-axis grid
                svg.append("g")
                    .attr("class", "grid")
                    .attr("transform", `translate(${margin.left},0)`)
                    .call(d3.axisLeft(y)
                        .ticks(numYTicks)
                        .tickSize(-(internalWidth - margin.left - margin.right))
                        .tickFormat("")
                    );

                // X-axis
                const xAxis = svg.append("g")
                    .attr("transform", `translate(0,${internalHeight - margin.bottom})`)
                    .call(d3.axisBottom(x).ticks(numXTicks));

                if (window.innerWidth <= 600) {
                    xAxis.selectAll("text")
                        .attr("transform", "rotate(-45)")
                        .style("text-anchor", "end");
                }

                // Y-axis with better formatting
                const yAxis = svg.append("g")
                    .attr("transform", `translate(${margin.left},0)`)
                    .call(d3.axisLeft(y)
                        .ticks(numYTicks)
                        .tickFormat(d => {
                            if (d >= 1000000) return `${(d/1000000).toFixed(1)}M`;
                            if (d >= 1000) return `${(d/1000).toFixed(1)}K`;
                            if (d >= 1) return `${d.toFixed(0)}x`;
                            return d.toFixed(2);
                        })
                    );

                // Y-axis label
                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", (window.innerWidth <= 400) ? 10 : (window.innerWidth <= 600 ? 10 : 15))
                    .attr("x", 0 - (internalHeight / 2))
                    .attr("dy", "-1em")
                    .style("text-anchor", "middle")
                    .text("Growth Multiplier");

                // Line generator
                const line = d3.line()
                    .x(d => x(d.date))
                    .y(d => y(d.price))
                    .curve(d3.curveLinear)
                    .defined(d => !isNaN(d.price) && d.price > 0); // Only draw valid points

                // Draw each line
                validDataSets.forEach(dataSet => {
                    svg.append("path")
                        .datum(dataSet.parsedData)
                        .attr("class", `line ${dataSet.cssClass}`)
                        .attr("fill", "none")
                        .attr("stroke", dataSet.color)
                        .attr("stroke-width", 2)
                        .attr("d", line);
                });

                // Title
                svg.append("text")
                    .attr("x", internalWidth / 2)
                    .attr("y", (window.innerWidth <= 400) ? 30 : (window.innerWidth <= 600 ? 25 : 20))
                    .attr("text-anchor", "middle")
                    .style("font-weight", "bold")
                    .text("CRYPTO RELATIVE GROWTH IN USD");

                // Add Legend
                const legend = svg.append("g")
                    .attr("class", "legend")
                    .attr("transform", `translate(${margin.left}, ${internalHeight - margin.bottom + 40})`);

                validDataSets.forEach((d, i) => {
                    const legendRow = legend.append("g")
                        .attr("transform", `translate(0, ${i * 20})`);

                    legendRow.append("rect")
                        .attr("width", 10)
                        .attr("height", 10)
                        .attr("fill", d.color);

                    legendRow.append("text")
                        .attr("x", 20)
                        .attr("y", 10)
                        .attr("text-anchor", "start")
                        .style("font-size", "0.8em")
                        .text(d.label);
                });

                // Add reference line at 1x
                svg.append("line")
                    .attr("x1", margin.left)
                    .attr("x2", internalWidth - margin.right)
                    .attr("y1", y(1))
                    .attr("y2", y(1))
                    .attr("stroke", "#666")
                    .attr("stroke-dasharray", "3,3")
                    .attr("opacity", 0.5);

                // Add 1x label
                svg.append("text")
                    .attr("x", margin.left + 5)
                    .attr("y", y(1) - 5)
                    .style("font-size", "0.7em")
                    .style("fill", "#666")
                    .text("1x");
            }

            // Use the improved chart function
            drawRelativeGrowthChart(
                cryptoRelativeGrowthUsdChartData,
                "crypto-relative-growth-usd-chart"
            );

        }
        // Run main when page loads
        main().catch(console.error);
    </script>
</body>

</html>
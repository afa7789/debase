<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>DEBASE</title>
    <link rel="icon" type="image/svg+xml" href="static/favicon.svg">
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
</head>

<body>

    <header>
        <a href="https://github.com/afa7789/debase">
            <h1>DEBASE</h1>
        </a>
    </header>

    <!-- Gold Chart -->
    <div id="gold-chart" class="brutalist-chart"></div>
    <div class="ath-display">
        <p><strong>Gold ATH Normal:</strong> <span id="gold-ath-normal"></span></p>
        <p><strong>Gold ATH Adjusted (Fixed):</strong> <span id="gold-ath-inflation-fixed"></span></p>
        <p><strong>Gold ATH Adjusted (1971):</strong> <span id="gold-ath-inflation-1971"></span></p>
    </div>
    <br>

    <!-- ETH Chart -->
    <div id="eth-chart" class="brutalist-chart"></div>
    <div class="ath-display">
        <p><strong>ETH ATH Normal:</strong> <span id="eth-ath-normal"></span></p>
        <p><strong>ETH ATH Adjusted (Fixed):</strong> <span id="eth-ath-inflation-fixed"></span></p>
        <p><strong>ETH ATH Adjusted (1971):</strong> <span id="eth-ath-inflation-1971"></span></p>
    </div>
    <br>

    <!-- Bitcoin Chart -->
    <div id="btc-chart" class="brutalist-chart"></div>
    <div class="ath-display">
        <p><strong>BTC ATH Normal:</strong> <span id="btc-ath-normal"></span></p>
        <p><strong>BTC ATH Adjusted (Fixed):</strong> <span id="btc-ath-inflation-fixed"></span></p>
        <p><strong>BTC ATH Adjusted (1971):</strong> <span id="btc-ath-inflation-1971"></span></p>
    </div>
    <br>

    <!-- XMR Chart -->
    <div id="xmr-chart" class="brutalist-chart"></div>
    <div class="ath-display">
        <p><strong>XMR ATH Normal:</strong> <span id="xmr-ath-normal"></span></p>
        <p><strong>XMR ATH Adjusted (Fixed):</strong> <span id="xmr-ath-inflation-fixed"></span></p>
        <p><strong>XMR ATH Adjusted (1971):</strong> <span id="xmr-ath-inflation-1971"></span></p>
    </div>
    <br>

    <!-- Gold-Adjusted Crypto Chart -->
    <div id="gold-adjusted-crypto-chart" class="brutalist-chart"></div>
    <div class="ath-display">
        <p><strong>ETH/Gold ATH:</strong> <span id="eth-gold-ath"></span></p>
        <p><strong>BTC/Gold ATH:</strong> <span id="btc-gold-ath"></span></p>
        <p><strong>XMR/Gold ATH:</strong> <span id="xmr-gold-ath"></span></p>
    </div>
    <br>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>

    <script>

        // Wait for idb to be available and define wrapper functions
        window.addEventListener('DOMContentLoaded', function () {
            console.log('idb library available:', typeof window.idb !== 'undefined');
            console.log('BigInt available:', typeof BigInt !== 'undefined');
        });

        // BigInt utility functions for financial calculations
        const SCALE = 1000000n; // 6 decimal places precision

        function toBigInt(value) {
            return BigInt(Math.round(value * Number(SCALE)));
        }

        function fromBigInt(bigintValue) {
            return Number(bigintValue) / Number(SCALE);
        }

        function bigIntDivide(numerator, denominator) {
            // Multiply by SCALE before division to maintain precision
            return (numerator * SCALE) / denominator;
        }

        function bigIntMultiply(a, b) {
            // Divide by SCALE after multiplication to maintain scale
            return (a * b) / SCALE;
        }

        // IndexedDB wrapper functions - must be defined before dataset_manager.js loads
        window.idbGet = async function (key) {
            try {
                // Check if idb is available
                if (typeof window.idb === 'undefined') {
                    throw new Error('idb library not loaded');
                }

                const db = await window.idb.openDB('csvDataStore', 1, {
                    upgrade(db) {
                        db.createObjectStore('datasets');
                    }
                });
                const result = await db.get('datasets', key);
                if (result !== undefined) return result;
            } catch (e) {
                console.warn('IndexedDB unavailable, falling back to localStorage:', e);
            }
            // Fallback to localStorage
            const stored = localStorage.getItem(key);
            return stored ? JSON.parse(stored) : null;
        };

        window.idbSet = async function (key, value) {
            try {
                // Check if idb is available
                if (typeof window.idb === 'undefined') {
                    throw new Error('idb library not loaded');
                }

                const db = await window.idb.openDB('csvDataStore', 1, {
                    upgrade(db) {
                        db.createObjectStore('datasets');
                    }
                });
                await db.put('datasets', value, key);
                return;
            } catch (e) {
                console.warn('IndexedDB unavailable, falling back to localStorage:', e);
            }
            // Fallback to localStorage
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (err) {
                console.error('Both IndexedDB and localStorage failed:', err);
            }
        };

        console.log('IndexedDB wrapper functions loaded');
    </script>

    <script src="scripts/dataset_manager.js"></script>

    <script src="scripts/import_from_kraken.js"></script>

    <script src="scripts/import_from_cpi.js"></script>

    <script>
        // The dates returned by csvManager.getFirstDate(GOLD) and csvManager.getFirstDate(CPI_U)
        // are strings in the format "YYYY-MM-DD,value1,value2,..."

        // Draw a brutalist D3 line chart - CSS-driven, mobile-first, NO DOTS
        // Modified to accept an array of data objects for multiple lines
        function drawCombinedChart(dataSets, divId = "combined-gold-chart", title = "PREÃ‡O DO OURO", labelLeft = "USD $") {
            const chartDiv = document.getElementById(divId);

            if (!chartDiv) {
                console.log(`Chart container with id ${divId} not found.`);
                return;
            }

            const containerWidth = chartDiv.clientWidth;
            const containerHeight = chartDiv.clientHeight > 0 ? chartDiv.clientHeight : (window.innerWidth <= 600 ? 400 : 400);

            const internalWidth = containerWidth;
            const internalHeight = (window.innerWidth <= 400) ? 450 : (window.innerWidth <= 600 ? 400 : 400);

            const margin = {
                top: (window.innerWidth <= 400) ? 60 : (window.innerWidth <= 600 ? 50 : 40),
                right: (window.innerWidth <= 400) ? 20 : (window.innerWidth <= 600 ? 25 : 30),
                bottom: (window.innerWidth <= 400) ? 80 : (window.innerWidth <= 600 ? 70 : 60),
                left: (window.innerWidth <= 400) ? 55 : (window.innerWidth <= 600 ? 50 : 60)
            };

            // Clear previous chart
            d3.select(`#${divId}`).selectAll("*").remove();

            // Prepare data for all lines and determine combined domains
            let allDates = [];
            let allPrices = [];

            dataSets.forEach(dataSet => {
                dataSet.parsedData = dataSet.data.timestamp.map((d, i) => ({
                    date: new Date(d),
                    price: dataSet.data.price[i]
                }));
                allDates = allDates.concat(dataSet.parsedData.map(d => d.date));
                allPrices = allPrices.concat(dataSet.parsedData.map(d => d.price));
            });

            // Create SVG
            const svg = d3.select(`#${divId}`)
                .append("svg")
                .attr("width", internalWidth)
                .attr("height", internalHeight);

            // Scales
            const x = d3.scaleTime()
                .domain(d3.extent(allDates))
                .range([margin.left, internalWidth - margin.right]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(allPrices) * 1.05]).nice()
                .range([internalHeight - margin.bottom, margin.top]);

            // Grid lines
            const numXTicks = (window.innerWidth <= 400) ? 3 : (window.innerWidth <= 600 ? 4 : 6);
            const numYTicks = (window.innerWidth <= 400) ? 4 : (window.innerWidth <= 600 ? 5 : 6);

            // X-axis grid
            svg.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(0,${internalHeight - margin.bottom})`)
                .call(d3.axisBottom(x)
                    .ticks(numXTicks)
                    .tickSize(-(internalHeight - margin.top - margin.bottom))
                    .tickFormat("")
                );

            // Y-axis grid
            svg.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y)
                    .ticks(numYTicks)
                    .tickSize(-(internalWidth - margin.left - margin.right))
                    .tickFormat("")
                );

            // X-axis
            const xAxis = svg.append("g")
                .attr("transform", `translate(0,${internalHeight - margin.bottom})`)
                .call(d3.axisBottom(x).ticks(numXTicks));

            if (window.innerWidth <= 600) {
                xAxis.selectAll("text")
                    .attr("transform", "rotate(-45)")
                    .style("text-anchor", "end");
            }

            // Y-axis
            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).ticks(numYTicks));

            // Y-axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", (window.innerWidth <= 400) ? 10 : (window.innerWidth <= 600 ? 10 : 20))
                .attr("x", 0 - (internalHeight / 2))
                .attr("dy", "-1em")
                .style("text-anchor", "middle")
                .text(labelLeft);

            // Line generator
            const line = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.price))
                .curve(d3.curveLinear);

            // Draw each line
            dataSets.forEach(dataSet => {
                svg.append("path")
                    .datum(dataSet.parsedData)
                    .attr("class", `line ${dataSet.cssClass}`) // Add a specific class for styling
                    .attr("fill", "none")
                    .attr("stroke", dataSet.color) // Use the assigned color
                    .attr("d", line);
            });

            // Title
            svg.append("text")
                .attr("x", internalWidth / 2)
                .attr("y", (window.innerWidth <= 400) ? 30 : (window.innerWidth <= 600 ? 25 : 20))
                .attr("text-anchor", "middle")
                .text(title.toUpperCase());

            // Add Legend
            const legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${margin.left}, ${internalHeight - margin.bottom + 40})`); // Position legend below the chart

            dataSets.forEach((d, i) => {
                const legendRow = legend.append("g")
                    .attr("transform", `translate(0, ${i * 20})`); // Spacing between legend items

                legendRow.append("rect")
                    .attr("width", 10)
                    .attr("height", 10)
                    .attr("fill", d.color);

                legendRow.append("text")
                    .attr("x", 20)
                    .attr("y", 10)
                    .attr("text-anchor", "start")
                    .style("font-size", "0.8em")
                    .text(d.label);
            });
        }

        // Function to calculate the difference in days between two dates in "YYYY-MM-DD" format
        function daysBetween(dateStr1, dateStr2) {
            const d1 = new Date(dateStr1);
            const d2 = new Date(dateStr2);
            // Difference in milliseconds
            const diffMs = d1 - d2;
            // Convert to days
            return Math.round(diffMs / (1000 * 60 * 60 * 24));
        }

        // Function to process asset data with inflation adjustments using BigInt
        function processAssetWithInflation(assetName, sliceRangeCPI_U, multiplierForAsset1971) {
            const infoAsset = csvManager.getDatasetInfo(assetName);

            const inflationFixedAsset = {
                ATH: 0n,
                timestamp: [],
                price: [],
            };
            const inflationAsset1971 = {
                ATH: 0n,
                timestamp: [],
                price: [],
            };
            const normalAsset = {
                ATH: 0n,
                timestamp: [],
                price: [],
            };

            let multiplierFor1971 = toBigInt(multiplierForAsset1971);
            let multiplierForStart = SCALE; // Start with 1.0 in BigInt scale
            let counter = 0;

            csvManager.iterateRange(assetName,
                infoAsset.firstDate,
                infoAsset.lastDate,
                (date, data) => {
                    let currentDailyMultiplicator = SCALE; // Default to 1.0
                    if (counter < sliceRangeCPI_U.length && sliceRangeCPI_U[counter]) {
                        currentDailyMultiplicator = toBigInt(sliceRangeCPI_U[counter].daily_multiplicator);
                    } else if (sliceRangeCPI_U.length > 0) {
                        currentDailyMultiplicator = toBigInt(sliceRangeCPI_U[sliceRangeCPI_U.length - 1].daily_multiplicator);
                    }

                    multiplierFor1971 = bigIntMultiply(multiplierFor1971, currentDailyMultiplicator);
                    multiplierForStart = bigIntMultiply(multiplierForStart, currentDailyMultiplicator);

                    // Calculate inflation adjusted price for 1971 base
                    const closePrice = toBigInt(data.Close);
                    const highPrice = toBigInt(data.High);

                    const inflationAdjustedPrice1971 = bigIntDivide(closePrice, multiplierFor1971);
                    const highIAP1971 = bigIntDivide(highPrice, multiplierFor1971);
                    if (highIAP1971 > inflationAsset1971.ATH) {
                        inflationAsset1971.ATH = highIAP1971;
                    }
                    inflationAsset1971.timestamp.push(date);
                    inflationAsset1971.price.push(fromBigInt(inflationAdjustedPrice1971));

                    // Calculate inflation adjusted price for asset start base
                    const inflationAdjustedPriceFixed = bigIntDivide(closePrice, multiplierForStart);
                    const highIAPFixed = bigIntDivide(highPrice, multiplierForStart);
                    if (highIAPFixed > inflationFixedAsset.ATH) {
                        inflationFixedAsset.ATH = highIAPFixed;
                    }
                    inflationFixedAsset.timestamp.push(date);
                    inflationFixedAsset.price.push(fromBigInt(inflationAdjustedPriceFixed));

                    // Normal Asset Price
                    if (highPrice > normalAsset.ATH) {
                        normalAsset.ATH = highPrice;
                    }
                    normalAsset.timestamp.push(date);
                    normalAsset.price.push(fromBigInt(closePrice));

                    counter++;
                }
            );

            return {
                normal: {
                    ATH: fromBigInt(normalAsset.ATH),
                    timestamp: normalAsset.timestamp,
                    price: normalAsset.price
                },
                inflationFixed: {
                    ATH: fromBigInt(inflationFixedAsset.ATH),
                    timestamp: inflationFixedAsset.timestamp,
                    price: inflationFixedAsset.price
                },
                inflation1971: {
                    ATH: fromBigInt(inflationAsset1971.ATH),
                    timestamp: inflationAsset1971.timestamp,
                    price: inflationAsset1971.price
                }
            };
        }

        // Function to calculate gold-adjusted crypto prices using BigInt
        function calculateGoldAdjustedCrypto(cryptoData, goldData) {
            const goldAdjustedCrypto = {
                ATH: 0n,
                timestamp: [],
                price: []
            };

            // Find overlapping dates
            const cryptoDates = new Set(cryptoData.timestamp);
            const goldMap = new Map();

            goldData.timestamp.forEach((date, i) => {
                goldMap.set(date, toBigInt(goldData.price[i]));
            });

            cryptoData.timestamp.forEach((date, i) => {
                if (goldMap.has(date)) {
                    const cryptoPrice = toBigInt(cryptoData.price[i]);
                    const goldPrice = goldMap.get(date);
                    const adjustedPrice = bigIntDivide(cryptoPrice, goldPrice);

                    if (adjustedPrice > goldAdjustedCrypto.ATH) {
                        goldAdjustedCrypto.ATH = adjustedPrice;
                    }

                    goldAdjustedCrypto.timestamp.push(date);
                    goldAdjustedCrypto.price.push(fromBigInt(adjustedPrice));
                }
            });

            return {
                ATH: fromBigInt(goldAdjustedCrypto.ATH),
                timestamp: goldAdjustedCrypto.timestamp,
                price: goldAdjustedCrypto.price
            };
        }

        // Main application logic
        async function main() {
            console.log("Accessing global csvManager object:", csvManager);

            const GOLD = "GOLD";
            const CPI_U = "CPI_U";
            const XMR = "XMR";
            const ETH = "ETH";
            const BTC = "BTC";

            const datasetConfigs = [
            { name: CPI_U, csvPath: '/datasets/daily_cpi_inflation.csv', fetchFunction: fetchCpiUData },
            { name: GOLD, csvPath: '/datasets/gold.csv', fetchFunction: fetchGoldData },
            { name: XMR, csvPath: '/datasets/monero_2014-05-21_2025-07-10.csv', fetchFunction: fetchXmrData },
            { name: ETH, csvPath: '/datasets/ethereum_2015-08-07_2025-07-10.csv', fetchFunction: fetchEthData },
            { name: BTC, csvPath: '/datasets/bitcoin_2010-07-17_2025-07-10.csv', fetchFunction: fetchBtcData },
            ];

            // Initialize all datasets
            await csvManager.initAllDatasets(datasetConfigs);

            // Get CPI_U data once, as it's the base for all inflation calculations
            const fullCpiUData = csvManager.getDataRange(
            CPI_U,
            csvManager.getFirstDate(CPI_U),
            csvManager.getLastDate(CPI_U)
            );
            const cpiUFirstDate = csvManager.getFirstDate(CPI_U);

            // Helper function to get asset-specific inflation data
            function getAssetInflationParams(assetInfo) {
            const daysAfterCpiUStart = daysBetween(
                assetInfo.firstDate,
                cpiUFirstDate
            );

            let assetSliceRangeCPI_U = fullCpiUData.slice(daysAfterCpiUStart);

            // Ensure the first daily_multiplicator for the sliced range is 1
            if (assetSliceRangeCPI_U.length > 0) {
                assetSliceRangeCPI_U[0].daily_multiplicator = 1;
            }

            let assetMultiplierFor1971 = SCALE; // Start with 1.0
            // Calculate the multiplier from CPI_U start (1971) up to the asset's start date
            for (let i = 0; i < daysAfterCpiUStart; i++) {
                if (fullCpiUData[i]) {
                assetMultiplierFor1971 = bigIntMultiply(assetMultiplierFor1971, toBigInt(fullCpiUData[i].daily_multiplicator));
                } else {
                break;
                }
            }
            return { sliceRangeCPI_U: assetSliceRangeCPI_U, multiplierFor1971: fromBigInt(assetMultiplierFor1971) };
            }

            // --- Process Gold data ---
            const infoGOLD = csvManager.getDatasetInfo(GOLD);
            const goldInflationParams = getAssetInflationParams(infoGOLD);
            const goldData = processAssetWithInflation(GOLD, goldInflationParams.sliceRangeCPI_U, goldInflationParams.multiplierFor1971);

            // Display Gold ATH values
            document.getElementById('gold-ath-normal').textContent = `$${goldData.normal.ATH.toFixed(2)}`;
            document.getElementById('gold-ath-inflation-fixed').textContent = `$${goldData.inflationFixed.ATH.toFixed(2)}`;
            document.getElementById('gold-ath-inflation-1971').textContent = `$${goldData.inflation1971.ATH.toFixed(2)}`;

            // Draw Gold chart
            const goldChartData = [
            { data: goldData.normal, label: "Gold Price (Normal)", color: "orange", cssClass: "normal-gold-line" },
            { data: goldData.inflationFixed, label: "Gold Inflation Adjusted (Fixed)", color: "blue", cssClass: "inflation-fixed-line" },
            { data: goldData.inflation1971, label: "Gold Inflation Adjusted (1971)", color: "green", cssClass: "inflation-1971-line" }
            ];
            drawCombinedChart(goldChartData, "gold-chart", "Gold Price", "USD $");

            // --- Process ETH data ---
            const infoETH = csvManager.getDatasetInfo(ETH);
            const ethInflationParams = getAssetInflationParams(infoETH);
            const ethData = processAssetWithInflation(ETH, ethInflationParams.sliceRangeCPI_U, ethInflationParams.multiplierFor1971);
            document.getElementById('eth-ath-normal').textContent = `$${ethData.normal.ATH.toFixed(2)}`;
            document.getElementById('eth-ath-inflation-fixed').textContent = `$${ethData.inflationFixed.ATH.toFixed(2)}`;
            document.getElementById('eth-ath-inflation-1971').textContent = `$${ethData.inflation1971.ATH.toFixed(2)}`;

            const ethChartData = [
            { data: ethData.normal, label: "ETH Price (Normal)", color: "purple", cssClass: "normal-eth-line" },
            { data: ethData.inflationFixed, label: "ETH Inflation Adjusted (Fixed)", color: "blue", cssClass: "inflation-fixed-eth-line" },
            { data: ethData.inflation1971, label: "ETH Inflation Adjusted (1971)", color: "green", cssClass: "inflation-1971-eth-line" }
            ];
            drawCombinedChart(ethChartData, "eth-chart", "Ethereum Price", "USD $");

            // --- Process BTC data ---
            const infoBTC = csvManager.getDatasetInfo(BTC);
            const btcInflationParams = getAssetInflationParams(infoBTC);
            const btcData = processAssetWithInflation(BTC, btcInflationParams.sliceRangeCPI_U, btcInflationParams.multiplierFor1971);
            document.getElementById('btc-ath-normal').textContent = `$${btcData.normal.ATH.toFixed(2)}`;
            document.getElementById('btc-ath-inflation-fixed').textContent = `$${btcData.inflationFixed.ATH.toFixed(2)}`;
            document.getElementById('btc-ath-inflation-1971').textContent = `$${btcData.inflation1971.ATH.toFixed(2)}`;

            const btcChartData = [
            { data: btcData.normal, label: "BTC Price (Normal)", color: "orange", cssClass: "normal-btc-line" },
            { data: btcData.inflationFixed, label: "BTC Inflation Adjusted (Fixed)", color: "blue", cssClass: "inflation-fixed-btc-line" },
            { data: btcData.inflation1971, label: "BTC Inflation Adjusted (1971)", color: "green", cssClass: "inflation-1971-btc-line" }
            ];
            drawCombinedChart(btcChartData, "btc-chart", "Bitcoin Price", "USD $");

            // --- Process XMR data ---
            const infoXMR = csvManager.getDatasetInfo(XMR);
            const xmrInflationParams = getAssetInflationParams(infoXMR);
            const xmrData = processAssetWithInflation(XMR, xmrInflationParams.sliceRangeCPI_U, xmrInflationParams.multiplierFor1971);
            document.getElementById('xmr-ath-normal').textContent = `$${xmrData.normal.ATH.toFixed(2)}`;
            document.getElementById('xmr-ath-inflation-fixed').textContent = `$${xmrData.inflationFixed.ATH.toFixed(2)}`;
            document.getElementById('xmr-ath-inflation-1971').textContent = `$${xmrData.inflation1971.ATH.toFixed(2)}`;

            const xmrChartData = [
            { data: xmrData.normal, label: "XMR Price (Normal)", color: "red", cssClass: "normal-xmr-line" },
            { data: xmrData.inflationFixed, label: "XMR Inflation Adjusted (Fixed)", color: "blue", cssClass: "inflation-fixed-xmr-line" },
            { data: xmrData.inflation1971, label: "XMR Inflation Adjusted (1971)", color: "green", cssClass: "inflation-1971-xmr-line" }
            ];
            drawCombinedChart(xmrChartData, "xmr-chart", "Monero Price", "USD $");

            // Calculate gold-adjusted crypto prices using BigInt
            const ethGoldAdjusted = calculateGoldAdjustedCrypto(ethData.normal, goldData.normal);
            const btcGoldAdjusted = calculateGoldAdjustedCrypto(btcData.normal, goldData.normal);
            const xmrGoldAdjusted = calculateGoldAdjustedCrypto(xmrData.normal, goldData.normal);

            document.getElementById('eth-gold-ath').textContent = `${ethGoldAdjusted.ATH.toFixed(6)} oz`;
            document.getElementById('btc-gold-ath').textContent = `${btcGoldAdjusted.ATH.toFixed(6)} oz`;
            document.getElementById('xmr-gold-ath').textContent = `${xmrGoldAdjusted.ATH.toFixed(6)} oz`;

            const goldAdjustedChartData = [
            { data: ethGoldAdjusted, label: "ETH/Gold", color: "purple", cssClass: "eth-gold-line" },
            { data: btcGoldAdjusted, label: "BTC/Gold", color: "orange", cssClass: "btc-gold-line" },
            { data: xmrGoldAdjusted, label: "XMR/Gold", color: "red", cssClass: "xmr-gold-line" }
            ];
            drawCombinedChart(goldAdjustedChartData, "gold-adjusted-crypto-chart", "Crypto Assets Adjusted by Gold", "Ounces of Gold");

        }
        // Run main when page loads
        main().catch(console.error);
    </script>
</body>

</html>